using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Skua.Core.Generators.Extensions;
using Skua.Core.Generators.Models;
using static Skua.Core.Generators.Diagnostics.DiagnosticDescriptors;

namespace Skua.Core.Generators;
public partial class MethodCallBindingGenerator
{
    public static class Execute
    {
        internal static MethodCallBindingPropertyInfo? TryGetInfo(IMethodSymbol methodSymbol, MethodDeclarationSyntax methodDeclaration, out ImmutableArray<Diagnostic> diagnostics)
        {
            ImmutableArray<Diagnostic>.Builder builder = ImmutableArray.CreateBuilder<Diagnostic>();

            string returnTypeWithNullabilityAnnotation = methodSymbol.ReturnType.GetFullyQualifiedNameWithNullabilityAnnotations();
            bool isNullable = methodSymbol.ReturnType.NullableAnnotation == NullableAnnotation.Annotated;
            string methodName = methodSymbol.Name;
            string methodBody = methodDeclaration.Body?.ToFullString().TrimStart(' ', '{', '\r', '\n').TrimEnd('}', '\r', '\n') ?? "";
            string methodParams = methodDeclaration.ParameterList.ToFullString();
            string[] methodParamNames = methodDeclaration.ParameterList.Parameters.Select(p => p.Identifier.Text).ToArray();
            string newMethodName = GetGeneratedMethodName(methodSymbol);

            // Check for name collisions
            if (methodName == newMethodName)
            {
                builder.Add(
                    MethodCallBindingMethodNameCollision,
                    methodSymbol,
                    methodSymbol.ContainingType,
                    methodSymbol.Name);

                diagnostics = builder.ToImmutable();
                return null;
            }
            bool runMethodPre = false, runMethodPost = false, gameFunction = false, parseFromJson = false;
            string path = string.Empty;
            string? defaultValue = null;
            // Gather attributes info
            foreach (AttributeData attributeData in methodSymbol.GetAttributes())
            {
                // Gather dependent property and command names
                if (TryGatherBindingName(methodSymbol, attributeData, Attributes.MethodCallBindingFullName, builder, CallBindingPathNullorEmpty, out path))
                {
                    defaultValue = attributeData.GetNamedArgument<string?>("Default", null);
                    runMethodPre = attributeData.GetNamedArgument("RunMethodPre", false);
                    runMethodPost = attributeData.GetNamedArgument("RunMethodPost", false);
                    gameFunction = attributeData.GetNamedArgument("GameFunction", false);
                    parseFromJson = attributeData.GetNamedArgument("ParseFromJson", false);
                    break;
                }
            }
            diagnostics = builder.ToImmutable();

            return new MethodCallBindingPropertyInfo(
                methodName,
                newMethodName,
                returnTypeWithNullabilityAnnotation,
                isNullable,
                methodParams,
                methodParamNames,
                methodBody,
                new MethodCallBindingValues(path, defaultValue, runMethodPre, runMethodPost, gameFunction, parseFromJson));
        }

        /// <summary>
        /// Processes the info to generate the final class.
        /// </summary>
        /// <param name="classInfo">The information about the class to generate.</param>
        /// <param name="methods">The fields to be added to the class.</param>
        /// <param name="suffix">A suffix for the name of the file.</param>
        /// <param name="context">The current context to generate the code.</param>
        internal static void GenerateClass(ClassInfo classInfo, ImmutableArray<MethodCallBindingPropertyInfo> methods, string suffix, SourceProductionContext context)
        {
            StringBuilder source = new($"// <auto-generated>\r\nnamespace {classInfo.Namespace};public partial class {classInfo.Name}{(string.IsNullOrWhiteSpace(classInfo.InheritanceFormattedNames) ? "" : $" : {classInfo.InheritanceFormattedNames}")} {{");
            foreach (MethodCallBindingPropertyInfo info in methods)
                GenerateMethods(source, info);
            source.Append("}");

            SyntaxTree tree = CSharpSyntaxTree.ParseText(source.ToString(), encoding: Encoding.UTF8);
            context.AddSource($"{classInfo.Name}_{suffix}.g.cs", tree.GetRoot().NormalizeWhitespace().ToFullString());
        }

        private static void GenerateMethods(StringBuilder source, MethodCallBindingPropertyInfo info)
        {
            string defaultValue = info.Values.Default is not null ? info.Values.Default : Default.Get(info.ReturnTypeString);
            bool isVoid = info.ReturnTypeString.Contains("void");
            string paramNames = info.MethodParamNames.Length == 0 ? "" : $", {string.Join(",", info.MethodParamNames)}";
            source.Append($"public {info.ReturnTypeString} {info.NewMethodName}{info.MethodParams}{{");
            if(info.Values.RunMethodPre)
                source.Append(info.MethodBody);
            if(info.Values.GameFunction)
            {
                if (isVoid)
                {
                    source.Append($"Flash.CallGameFunction(\"{info.Values.Path}\"{paramNames});");
                }
                else
                {
                    source.Append($"try{{string ret = Flash.CallGameFunction(\"{info.Values.Path}\"{paramNames});");
                    source.Append($"{info.ReturnTypeString} returnValue = Newtonsoft.Json.JsonConvert.DeserializeObject<{info.ReturnTypeString}>(ret);");
                }
            }
            else
            {
                if (isVoid)
                {
                    source.Append($"Flash.Call(\"{info.Values.Path}\"{paramNames});");
                }
                else
                {
                    if(info.Values.ParseFromJson)
                    {
                        source.Append($"try{{string ret = Flash.Call<string>(\"{info.Values.Path}\"{paramNames});");
                        source.Append($"{info.ReturnTypeString} returnValue = Newtonsoft.Json.JsonConvert.DeserializeObject<{info.ReturnTypeString}>(ret);");
                    }
                    else
                    {
                        source.Append($"try{{{info.ReturnTypeString} returnValue = Flash.Call<{info.ReturnTypeString}>(\"{info.Values.Path}\"{paramNames});");
                    }
                }
            }
            if(info.Values.RunMethodPost && !info.Values.RunMethodPre)
                source.Append(info.MethodBody);

            if (!isVoid)
            {
                source.Append($"return returnValue{(info.IsNullable ? $" ?? {defaultValue}" : string.Empty)};");
                source.Append($"}}catch{{return {defaultValue};}}");
            }

            source.Append("}");
        }

        /// <summary>
        /// Get the generated method name for an input method.
        /// </summary>
        /// <param name="methodSymbol">The input <see cref="IFieldSymbol"/> instance to process.</param>
        /// <returns>The generated property name for <paramref name="fieldSymbol"/>.</returns>
        public static string GetGeneratedMethodName(IMethodSymbol methodSymbol)
        {
            string propertyName = methodSymbol.Name;

            if (propertyName.StartsWith("m_"))
            {
                propertyName = propertyName.Substring(2);
            }
            else if (propertyName.StartsWith("_"))
            {
                propertyName = propertyName.TrimStart('_');
            }

            return $"{char.ToUpper(propertyName[0], CultureInfo.InvariantCulture)}{propertyName.Substring(1)}";
        }

        /// <summary>
        /// Tries to gather dependent properties from the given attribute.
        /// </summary>
        /// <param name="methodSymbol">The input <see cref="IMethodSymbol"/> instance to process.</param>
        /// <param name="attributeData">The <see cref="AttributeData"/> instance for <paramref name="methodSymbol"/>.</param>
        /// <param name="diagnostics">The current collection of gathered diagnostics.</param>
        /// <param name="descriptor">The descriptor to use if no binding is found.</param>
        /// <param name="bindingName">The name/path found in the attribute constructor.</param>
        /// <returns>Whether <paramref name="attributeData"/> has a defined name/path.</returns>
        public static bool TryGatherBindingName(IMethodSymbol methodSymbol, AttributeData attributeData, string attributeFullName, ImmutableArray<Diagnostic>.Builder diagnostics, DiagnosticDescriptor descriptor, out string bindingName)
        {
            if (attributeData.AttributeClass?.HasFullyQualifiedName(attributeFullName) == true)
            {
                foreach (string? name in attributeData.GetConstructorArguments<string>())
                {
                    if (!string.IsNullOrWhiteSpace(name))
                    {
                        bindingName = name!;
                        return true;
                    }
                    else
                    {
                        diagnostics.Add(
                            descriptor,
                            methodSymbol,
                            methodSymbol.ContainingType,
                            methodSymbol.Name);
                        break;
                    }
                }
            }
            bindingName = string.Empty;
            return false;
        }
    }
}
