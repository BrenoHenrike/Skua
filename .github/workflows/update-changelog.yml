name: Update Changelog

on:
  release:
    types: [published]
  workflow_dispatch:  # Allow manual triggering for testing

jobs:
  update-changelog:
    name: Update changelogs.md
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: üìã Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üìÑ Get release information
      id: release
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          echo "RELEASE_TAG=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          echo "RELEASE_NAME=${{ github.event.release.name }}" >> $GITHUB_OUTPUT
          echo "RELEASE_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "${{ github.event.release.body }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "RELEASE_PUBLISHED_AT=${{ github.event.release.published_at }}" >> $GITHUB_OUTPUT
        else
          # Manual trigger - get latest release
          LATEST_RELEASE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          echo "RELEASE_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')" >> $GITHUB_OUTPUT
          echo "RELEASE_NAME=$(echo "$LATEST_RELEASE" | jq -r '.name')" >> $GITHUB_OUTPUT
          echo "RELEASE_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$LATEST_RELEASE" | jq -r '.body' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "RELEASE_PUBLISHED_AT=$(echo "$LATEST_RELEASE" | jq -r '.published_at')" >> $GITHUB_OUTPUT
        fi
        
    - name: üîÑ Update changelogs.md
      env:
        RELEASE_TAG: ${{ steps.release.outputs.RELEASE_TAG }}
        RELEASE_NAME: ${{ steps.release.outputs.RELEASE_NAME }}
        RELEASE_BODY: ${{ steps.release.outputs.RELEASE_BODY }}
        RELEASE_PUBLISHED_AT: ${{ steps.release.outputs.RELEASE_PUBLISHED_AT }}
      run: |
        # Update changelog using Python script
        python3 -c "
        import os
        import re
        from datetime import datetime
        
        # Get release information from environment variables
        release_tag = os.environ.get('RELEASE_TAG', '')
        release_name = os.environ.get('RELEASE_NAME', '') or release_tag
        release_body = os.environ.get('RELEASE_BODY', '') or 'No release notes provided.'
        release_published_at = os.environ.get('RELEASE_PUBLISHED_AT', '')
        
        print(f'Processing release: {release_name} ({release_tag})')
        print(f'Published at: {release_published_at}')
        print(f\"Body preview: {release_body[:100]}...\" if len(release_body) > 100 else f'Body: {release_body}')
        
        # Format the date
        try:
            if release_published_at:
                dt = datetime.fromisoformat(release_published_at.replace('Z', '+00:00'))
                formatted_date = dt.strftime('%B %d, %Y')
            else:
                formatted_date = 'Unknown date'
        except:
            formatted_date = release_published_at
        
        print(f'Formatted date: {formatted_date}')
        
        # Check if changelogs.md exists
        if not os.path.exists('changelogs.md'):
            print('üÜï Creating new changelogs.md file...')
            # Create with header
            with open('changelogs.md', 'w', encoding='utf-8') as f:
                f.write('# Skua Release Changelog\\n\\n')
                f.write('This file is automatically updated when new releases are published.\\n\\n')
                f.write('---\\n\\n')
                # Add the new release
                f.write(f'# {release_name}\\n')
                f.write(f'## Released: {formatted_date}\\n\\n')
                f.write(f'{release_body}\\n\\n')
                f.write('---\\n\\n')
            print('‚úÖ Created new changelog with release')
        else:
            # Read existing changelog
            with open('changelogs.md', 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check if this release already exists
            existing_headers = re.findall(r'^# (.+)$', content, re.MULTILINE)
            if release_name in existing_headers:
                print(f\"üîÑ Release '{release_name}' already exists in changelog. Updating entry...\")
                
                # Replace existing entry with updated content
                lines = content.split('\\n')
                new_lines = []
                in_target_release = False
                updated = False
                
                for line in lines:
                    if line.startswith('# ') and line[2:] == release_name and not updated:
                        # Start of target release - replace it
                        new_lines.append(f'# {release_name}')
                        new_lines.append(f'## Released: {formatted_date}')
                        new_lines.append('')
                        new_lines.append(release_body)
                        new_lines.append('')
                        new_lines.append('---')
                        new_lines.append('')
                        in_target_release = True
                        updated = True
                    elif line.startswith('# ') and in_target_release:
                        # Start of next release - stop skipping
                        in_target_release = False
                        new_lines.append(line)
                    elif line == '---' and in_target_release:
                        # End of current release section - stop skipping
                        in_target_release = False
                        # Don't add this line as we already added the separator above
                    elif not in_target_release:
                        new_lines.append(line)
                    # Skip lines that are part of the old release entry
                
                # Write updated content
                with open('changelogs.md', 'w', encoding='utf-8') as f:
                    f.write('\\n'.join(new_lines))
                print('‚úÖ Updated existing release entry')
            else:
                print(f\"‚ûï Adding new release '{release_name}' to changelog...\")
                
                # Find the insertion point (after first --- separator)
                lines = content.split('\\n')
                new_lines = []
                inserted = False
                
                for i, line in enumerate(lines):
                    new_lines.append(line)
                    if line == '---' and not inserted:
                        # Found first separator, insert new release after it
                        new_lines.append('')
                        new_lines.append(f'# {release_name}')
                        new_lines.append(f'## Released: {formatted_date}')
                        new_lines.append('')
                        new_lines.append(release_body)
                        new_lines.append('')
                        new_lines.append('---')
                        new_lines.append('')
                        inserted = True
                
                # Write updated content
                with open('changelogs.md', 'w', encoding='utf-8') as f:
                    f.write('\\n'.join(new_lines))
                print('‚úÖ Added new release entry')
        
        # Count total releases
        with open('changelogs.md', 'r', encoding='utf-8') as f:
            content = f.read()
            # Count headers that are not the main changelog header
            all_headers = re.findall(r'^# (.+)$', content, re.MULTILINE)
            release_count = len([h for h in all_headers if h != 'Skua Release Changelog'])
            print(f'üìä Changelog now contains {release_count} releases')
        
        print('Release update completed')
        " || exit 1
        
        echo "‚úÖ Changelog updated successfully"
        
    - name: üìù Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet changelogs.md; then
          echo "No changes to commit"
        else
          git add changelogs.md
          git commit -m "Update changelog for release ${{ steps.release.outputs.RELEASE_TAG }} [skip ci]"
          
          # Pull latest changes and rebase to avoid conflicts
          echo "Pulling latest changes from remote..."
          git pull --rebase origin ${{ github.ref_name }}
          
          # Push the changes
          git push origin ${{ github.ref_name }}
          echo "‚úÖ Changelog updated and committed"
        fi
        
    - name: üì§ Update op-version branch (for compatibility)
      run: |
        # Update the op-version branch with the latest changelog
        git fetch origin
        if git branch -r | grep -q "origin/op-version"; then
          git checkout -B op-version origin/op-version
          cp changelogs.md changelogs_op.md
          
          # Check if op-version branch has differences
          if git diff --quiet changelogs.md; then
            echo "op-version branch already up to date"
          else
            git add changelogs.md
            git commit -m "Sync changelog from master for release ${{ steps.release.outputs.RELEASE_TAG }} [skip ci]" || true
            git push origin op-version
            echo "‚úÖ op-version branch updated"
          fi
        else
          echo "op-version branch does not exist, skipping compatibility update"
        fi
      continue-on-error: true  # Don't fail the entire workflow if this step fails
