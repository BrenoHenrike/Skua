name: Populate Changelog with Existing Releases

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      max_releases:
        description: 'Maximum number of releases to include'
        required: false
        default: '10'
        type: string

jobs:
  populate-changelog:
    name: Populate changelogs.md with existing releases
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: ğŸ“‹ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: ğŸ“„ Get all releases and create changelog
      run: |
        MAX_RELEASES="${{ github.event.inputs.max_releases || '10' }}"
        echo "Getting up to $MAX_RELEASES releases..."
        
        # Backup existing changelog if it exists
        if [ -f "changelogs.md" ]; then
          cp changelogs.md changelogs.md.backup
          echo "ğŸ“ Backed up existing changelog"
        fi
        
        # Create new changelog with header
        cat > changelogs.md << 'HEADER_END'
# Skua Release Changelog

This file is automatically updated when new releases are published.

---

HEADER_END
        
        # Get releases from GitHub API and process them directly
        echo "Fetching releases from GitHub API..."
        
        # Create a Python script to handle the JSON processing properly
        cat > process_releases.py << 'PYTHON_END'
import json
import sys
import requests
import os
from datetime import datetime

# Get GitHub token and repository info
token = os.environ.get('GITHUB_TOKEN')
repo = os.environ.get('GITHUB_REPOSITORY')
max_releases = int(os.environ.get('MAX_RELEASES', '10'))

if not token or not repo:
    print("Error: Missing GitHub token or repository info")
    sys.exit(1)

# Fetch releases from GitHub API
url = f"https://api.github.com/repos/{repo}/releases"
headers = {
    'Authorization': f'token {token}',
    'Accept': 'application/vnd.github.v3+json'
}

response = requests.get(url, headers=headers, params={'per_page': max_releases})
if response.status_code != 200:
    print(f"Error fetching releases: {response.status_code}")
    sys.exit(1)

releases = response.json()

# Filter out drafts and prereleases, then sort by published date (newest first)
filtered_releases = [r for r in releases if not r.get('draft', False) and not r.get('prerelease', False)]
filtered_releases.sort(key=lambda x: x.get('published_at', ''), reverse=True)

print(f"Found {len(filtered_releases)} published releases")

# Read existing changelog to check for duplicates
existing_releases = set()
if os.path.exists('changelogs.md'):
    try:
        with open('changelogs.md', 'r', encoding='utf-8') as f:
            content = f.read()
            # Extract existing release headers
            import re
            headers = re.findall(r'^# (.+)$', content, re.MULTILINE)
            existing_releases = set(headers)
        print(f"Found {len(existing_releases)} existing releases in changelog")
    except Exception as e:
        print(f"Error reading existing changelog: {e}")
        existing_releases = set()

# Process each release and append to changelog
with open('changelogs.md', 'a', encoding='utf-8') as f:
    new_releases_added = 0
    for release in filtered_releases:
        tag = release.get('tag_name', '')
        name = release.get('name', '') or tag
        published_at = release.get('published_at', '')
        body = release.get('body', '') or 'No release notes provided.'
        
        # Check if this release already exists
        if name in existing_releases:
            print(f"Skipping existing release: {name}")
            continue
        
        # Format the date
        try:
            if published_at:
                dt = datetime.fromisoformat(published_at.replace('Z', '+00:00'))
                formatted_date = dt.strftime('%B %d, %Y')
            else:
                formatted_date = 'Unknown date'
        except:
            formatted_date = published_at
        
        print(f"Adding new release: {name} ({tag}) - {formatted_date}")
        
        # Write the release entry
        f.write(f"# {name}\n")
        f.write(f"## Released: {formatted_date}\n\n")
        f.write(f"{body}\n\n")
        f.write("---\n\n")
        new_releases_added += 1

print(f"Added {new_releases_added} new releases to changelog")

print("Changelog generation completed")
PYTHON_END
        
        # Set environment variables for Python script
        export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
        export GITHUB_REPOSITORY="${{ github.repository }}"
        export MAX_RELEASES="$MAX_RELEASES"
        
        # Run the Python script
        python3 process_releases.py
        
        if [ $? -eq 0 ]; then
          echo "âœ… Changelog generated successfully"
        else
          echo "âŒ Failed to generate changelog"
          exit 1
        fi
        
    - name: ğŸ” Show changelog preview
      run: |
        echo "ğŸ“„ Changelog preview (first 100 lines):"
        head -100 changelogs.md
        echo ""
        echo "ğŸ“Š Changelog statistics:"
        echo "- Total lines: $(wc -l < changelogs.md)"
        echo "- Number of releases: $(grep -c '^# ' changelogs.md || echo 0)"
        echo "- File size: $(du -h changelogs.md | cut -f1)"
        
    - name: ğŸ“ Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet changelogs.md; then
          echo "No changes to commit"
        else
          git add changelogs.md
          git commit -m "Populate changelog with existing releases [skip ci]"
          git push origin ${{ github.ref_name }}
          echo "âœ… Changelog populated and committed"
          
          # Also update op-version branch for compatibility
          if git branch -r | grep -q "origin/op-version"; then
            git checkout -B op-version origin/op-version || git checkout -b op-version
            cp changelogs.md changelogs_op_version.md
            if ! git diff --quiet changelogs.md 2>/dev/null; then
              git add changelogs.md
              git commit -m "Sync populated changelog from master [skip ci]" || true
              git push origin op-version || true
              echo "âœ… op-version branch also updated"
            fi
          fi
        fi
        
    - name: ğŸ—‘ï¸ Cleanup
      run: |
        rm -f process_releases.py changelogs.md.backup changelogs_op_version.md
        echo "âœ… Cleanup completed"
