name: Populate Changelog with Existing Releases

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      max_releases:
        description: 'Maximum number of releases to include'
        required: false
        default: '10'
        type: string

jobs:
  populate-changelog:
    name: Populate changelogs.md with existing releases
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: üìã Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üìÑ Get all releases and create changelog
      run: |
        MAX_RELEASES="${{ github.event.inputs.max_releases || '10' }}"
        echo "Getting up to $MAX_RELEASES releases..."
        
        # Backup existing changelog if it exists
        if [ -f "changelogs.md" ]; then
          cp changelogs.md changelogs.md.backup
          echo "üìÅ Backed up existing changelog"
        fi
        
        # Create Python script to process releases
        python3 -c "
        import json
        import sys
        import requests
        import os
        import re
        from datetime import datetime
        
        # Get GitHub token and repository info
        token = os.environ.get('GITHUB_TOKEN', '${{ secrets.GITHUB_TOKEN }}')
        repo = os.environ.get('GITHUB_REPOSITORY', '${{ github.repository }}')
        max_releases = int(os.environ.get('MAX_RELEASES', '10'))
        
        if not token or not repo:
            print('Error: Missing GitHub token or repository info')
            sys.exit(1)
        
        # Fetch releases from GitHub API
        url = f'https://api.github.com/repos/{repo}/releases'
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        response = requests.get(url, headers=headers, params={'per_page': max_releases})
        if response.status_code != 200:
            print(f'Error fetching releases: {response.status_code}')
            sys.exit(1)
        
        releases = response.json()
        
        # Filter out drafts and prereleases, then sort by published date (newest first)
        filtered_releases = [r for r in releases if not r.get('draft', False) and not r.get('prerelease', False)]
        filtered_releases.sort(key=lambda x: x.get('published_at', ''), reverse=True)
        
        print(f'Found {len(filtered_releases)} published releases')
        
        # Create or check existing changelog
        existing_releases = set()
        if os.path.exists('changelogs.md'):
            try:
                with open('changelogs.md', 'r', encoding='utf-8') as f:
                    content = f.read()
                    headers = re.findall(r'^# (.+)$', content, re.MULTILINE)
                    existing_releases = set(headers)
                print(f'Found {len(existing_releases)} existing releases in changelog')
            except Exception as e:
                print(f'Error reading existing changelog: {e}')
                # Create new file
                with open('changelogs.md', 'w', encoding='utf-8') as f:
                    f.write('# Skua Release Changelog\n\n')
                    f.write('This file is automatically updated when new releases are published.\n\n')
                    f.write('---\n\n')
        else:
            # Create new file with header
            with open('changelogs.md', 'w', encoding='utf-8') as f:
                f.write('# Skua Release Changelog\n\n')
                f.write('This file is automatically updated when new releases are published.\n\n')
                f.write('---\n\n')
        
        # Process each release and append to changelog
        with open('changelogs.md', 'a', encoding='utf-8') as f:
            new_releases_added = 0
            for release in filtered_releases:
                tag = release.get('tag_name', '')
                name = release.get('name', '') or tag
                published_at = release.get('published_at', '')
                body = release.get('body', '') or 'No release notes provided.'
                
                # Check if this release already exists
                if name in existing_releases:
                    print(f'Skipping existing release: {name}')
                    continue
                
                # Format the date
                try:
                    if published_at:
                        dt = datetime.fromisoformat(published_at.replace('Z', '+00:00'))
                        formatted_date = dt.strftime('%B %d, %Y')
                    else:
                        formatted_date = 'Unknown date'
                except:
                    formatted_date = published_at
                
                print(f'Adding new release: {name} ({tag}) - {formatted_date}')
                
                # Write the release entry
                f.write(f'# {name}\n')
                f.write(f'## Released: {formatted_date}\n\n')
                f.write(f'{body}\n\n')
                f.write('---\n\n')
                new_releases_added += 1
        
        print(f'Added {new_releases_added} new releases to changelog')
        print('Changelog generation completed')
        " || exit 1
        
        echo "‚úÖ Changelog processed successfully"
        
    - name: üîç Show changelog preview
      run: |
        echo "üìÑ Changelog preview (first 100 lines):"
        head -100 changelogs.md
        echo ""
        echo "üìä Changelog statistics:"
        echo "- Total lines: $(wc -l < changelogs.md)"
        echo "- Number of releases: $(grep -c '^# ' changelogs.md || echo 0)"
        echo "- File size: $(du -h changelogs.md | cut -f1)"
        
    - name: üìù Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet changelogs.md; then
          echo "No changes to commit"
        else
          git add changelogs.md
          git commit -m "Populate changelog with existing releases [skip ci]"
          
          # Pull latest changes and rebase to avoid conflicts
          echo "Pulling latest changes from remote..."
          git fetch origin
          
          # Try to rebase, but if it fails, abort and merge instead
          if git rebase origin/${{ github.ref_name }}; then
            echo "Rebase successful"
          else
            echo "Rebase failed, attempting merge strategy..."
            git rebase --abort
            git pull origin ${{ github.ref_name }} --strategy=ours
          fi
          
          # Push the changes (with force-with-lease for safety)
          git push origin ${{ github.ref_name }} || git push --force-with-lease origin ${{ github.ref_name }}
          echo "‚úÖ Changelog populated and committed"
          
          # Also update op-version branch for compatibility
          if git branch -r | grep -q "origin/op-version"; then
            git checkout -B op-version origin/op-version || git checkout -b op-version
            cp changelogs.md changelogs_op_version.md
            if ! git diff --quiet changelogs.md 2>/dev/null; then
              git add changelogs.md
              git commit -m "Sync populated changelog from master [skip ci]" || true
              git push origin op-version || true
              echo "‚úÖ op-version branch also updated"
            fi
          fi
        fi
        
    - name: üóëÔ∏è Cleanup
      run: |
        rm -f changelogs.md.backup changelogs_op_version.md
        echo "‚úÖ Cleanup completed"
